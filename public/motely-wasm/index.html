<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Motely.WASM Analyzer</title>
  <style>
    body { font-family: system-ui; max-width: 1100px; margin: 2rem auto; padding: 1rem; }
    h1 { margin-bottom: 0.5rem; }
    .split { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
    .row { display: flex; flex-wrap: wrap; gap: 0.75rem; align-items: center; }
    label { display: flex; flex-direction: column; font-size: 0.9rem; gap: 0.25rem; }
    input, select, textarea { padding: 0.5rem; font-size: 1rem; min-width: 140px; }
    button { padding: 0.6rem 1rem; font-size: 1rem; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    textarea { font-family: ui-monospace, monospace; font-size: 12px; width: 100%; height: 320px; padding: 0.75rem; box-sizing: border-box; }
    pre { background: #f6f6f6; padding: 0.75rem; overflow: auto; max-height: 220px; font-size: 11px; }
    #status { font-weight: bold; }
    .error { color: red; }
    .success { color: green; }
    .section { margin: 1rem 0; }
    .subtle { font-size: 0.85rem; color: #666; }
    .tabs { display: flex; flex-wrap: wrap; gap: 0.5rem; margin: 0.5rem 0 1rem; }
    .tab-btn { padding: 0.4rem 0.75rem; border: 1px solid #ccc; background: #fff; border-radius: 6px; }
    .tab-btn.active { background: #111; color: #fff; border-color: #111; }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
    @media (max-width: 980px) {
      .split { grid-template-columns: 1fr; }
      textarea { height: 280px; }
    }
  </style>
</head>
<body>
  <h1>Motely.WASM Analyzer</h1>
  <p id="status">Loading .NET WASM runtime...</p>

  <div id="controls" style="display:none" class="split">
    <div>
      <h2>Analyzer</h2>
      <div class="section row">
        <label>Seed
          <input id="seed" value="TACO1111" placeholder="TACO1111">
        </label>
        <label>Deck
          <input id="deck" list="deckList" value="Red">
          <datalist id="deckList">
            <option>Red</option><option>Blue</option><option>Green</option><option>Yellow</option>
            <option>Black</option><option>Magic</option><option>Nebula</option><option>Ghost</option>
            <option>Abandoned</option><option>Checkered</option><option>Erratic</option>
          </datalist>
        </label>
        <label>Stake
          <input id="stake" list="stakeList" value="White">
          <datalist id="stakeList">
            <option>White</option><option>Red</option><option>Green</option><option>Black</option>
            <option>Blue</option><option>Purple</option><option>Orange</option><option>Gold</option>
          </datalist>
        </label>
        <label>Min Ante
          <input id="minAnte" type="number" min="1" max="8" value="1">
        </label>
        <label>Max Ante
          <input id="maxAnte" type="number" min="1" max="8" value="8">
        </label>
        <button id="analyzeBtn">Analyze</button>
        <button id="clearBtn">Clear</button>
      </div>

      <div class="section">
        <label>Output (text)
          <textarea id="out" readonly>—</textarea>
        </label>
      </div>

      <details class="section">
        <summary style="cursor:pointer;">Raw JSON</summary>
        <pre id="rawJson">—</pre>
      </details>
    </div>

    <div>
      <h2>Search (JAML)</h2>
      <div class="section">
        <label>JAML filter
          <textarea id="jaml">name: Perkeo Observatory (Enhanced!)
author: Athuny & pifreak
description: PerkeoObservatory classic setup, but Ante 1 super goopy!
deck: Ghost
stake: White

Must:
  - voucher: Telescope
    antes: [1]
  - voucher: Observatory
    antes: [2]
  - soulJoker: Perkeo
    antes: [1, 2, 3]

Should:
  - jokers: [Blueprint, Brainstorm]
    antes: [1, 2, 3]
    score: 225</textarea>
        </label>
        <p class="subtle">Tip: For quick local testing, use a small seed list.</p>
      </div>
      <div class="section row">
        <label>Threads
          <input id="threadCount" type="number" value="" placeholder="auto" min="1" max="32">
        </label>
        <label>Batch size
          <input id="batchSize" type="number" value="4" min="1" max="7">
        </label>
      </div>
      <div class="section">
        <div class="tabs" id="searchTabs">
          <button class="tab-btn active" data-tab="seed">Seed list</button>
          <button class="tab-btn" data-tab="keyword">Keyword</button>
          <button class="tab-btn" data-tab="random">Random</button>
          <button class="tab-btn" data-tab="palindrome">Palindrome</button>
        </div>
        <div class="tab-panel active" data-tab-panel="seed">
          <div class="row">
            <label>Seed list (comma / space / newline)
              <input id="seedList" placeholder="TACO1111 TACO1112">
            </label>
            <label>Seed list file
              <input id="seedFile" type="file" accept=".txt,.csv">
            </label>
          </div>
        </div>
        <div class="tab-panel" data-tab-panel="keyword">
          <div class="row">
            <label>Keyword (single)
              <input id="keyword" placeholder="PERKEO">
            </label>
            <label>Keywords (comma / space / newline)
              <input id="keywordList" placeholder="PERKEO,OBSERVE">
            </label>
            <label>Keyword list file
              <input id="keywordFile" type="file" accept=".txt,.csv">
            </label>
            <label>Padding chars
              <input id="paddingChars" placeholder="1ABC">
            </label>
          </div>
        </div>
        <div class="tab-panel" data-tab-panel="random">
          <div class="row">
            <label>Random seeds
              <input id="randomSeeds" type="number" min="1" step="1" placeholder="(required)">
            </label>
          </div>
        </div>
        <div class="tab-panel" data-tab-panel="palindrome">
          <div class="row">
            <label style="flex-direction:row; gap:0.5rem; align-items:center; margin-top:0.5rem;">
              <input id="palindrome" type="checkbox" checked>
              Palindrome search
            </label>
          </div>
        </div>
      </div>
      <details class="section">
        <summary style="cursor:pointer;">Advanced ranges</summary>
        <div class="row" style="margin-top:0.5rem;">
          <label>Start seed
            <input id="startSeed" placeholder="TACO1111">
          </label>
          <label>Start %
            <input id="startPercent" type="number" min="0" max="100" step="0.1" placeholder="0">
          </label>
          <label>End %
            <input id="endPercent" type="number" min="0" max="100" step="0.1" placeholder="0">
          </label>
          <label>Start batch
            <input id="startBatch" type="number" min="0" step="1" placeholder="0">
          </label>
          <label>End batch
            <input id="endBatch" type="number" min="0" step="1" placeholder="0">
          </label>
          <label>Cutoff
            <input id="cutoff" placeholder="auto / best / 0 / 25">
          </label>
        </div>
      </details>
      <div class="section row">
        <button id="searchBtn">Run search</button>
        <button id="cancelBtn" style="display:none">Cancel</button>
      </div>

      <div class="section">
        <label>Search output
          <textarea id="searchOut" readonly>—</textarea>
        </label>
      </div>

      <details class="section">
        <summary style="cursor:pointer;">Search JSON</summary>
        <pre id="searchJson">—</pre>
      </details>
    </div>
  </div>

  <script type="module">
    const status = document.getElementById('status');
    const controls = document.getElementById('controls');
    const out = document.getElementById('out');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const clearBtn = document.getElementById('clearBtn');
    const rawJsonEl = document.getElementById('rawJson');
    const jamlEl = document.getElementById('jaml');
    const searchBtn = document.getElementById('searchBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const searchOut = document.getElementById('searchOut');
    const searchJson = document.getElementById('searchJson');
    const threadCountEl = document.getElementById('threadCount');
    const batchSizeEl = document.getElementById('batchSize');
    const seedListEl = document.getElementById('seedList');
    const seedFileEl = document.getElementById('seedFile');
    const keywordEl = document.getElementById('keyword');
    const keywordListEl = document.getElementById('keywordList');
    const keywordFileEl = document.getElementById('keywordFile');
    const paddingCharsEl = document.getElementById('paddingChars');
    const startSeedEl = document.getElementById('startSeed');
    const startPercentEl = document.getElementById('startPercent');
    const endPercentEl = document.getElementById('endPercent');
    const startBatchEl = document.getElementById('startBatch');
    const endBatchEl = document.getElementById('endBatch');
    const cutoffEl = document.getElementById('cutoff');
    const randomSeedsEl = document.getElementById('randomSeeds');
    const palindromeEl = document.getElementById('palindrome');
    const searchTabs = document.getElementById('searchTabs');

    let seedFileText = '';
    let keywordFileText = '';
    let cancelRequested = false;
    let activeTab = 'seed';

    function formatAnalysis(data) {
      if (!data) return 'No data.';
      if (data.error) return 'Error: ' + data.error;
      const lines = [];
      lines.push('Seed: ' + (data.seed || ''));
      lines.push('Deck: ' + (data.deck || '') + '   Stake: ' + (data.stake || ''));
      if (data.erraticDeckComposition && data.erraticDeckComposition.length) {
        lines.push('Erratic: ' + data.erraticDeckComposition.join(', '));
      }
      lines.push('');
      const antes = data.antes || [];
      if (!antes.length) {
        lines.push('No ante data returned.');
        return lines.join('\n');
      }
      for (const ante of antes) {
        lines.push('==ANTE ' + ante.ante + '==');
        lines.push('Boss: ' + (ante.boss || '—'));
        lines.push('Voucher: ' + (ante.voucher || '—'));
        const tags = [ante.smallBlindTag, ante.bigBlindTag].filter(t => t && t !== 'None');
        lines.push('Tags: ' + (tags.length ? tags.join(', ') : '—'));
        lines.push('Shop Queue:');
        if (ante.shopQueue && ante.shopQueue.length) {
          ante.shopQueue.forEach((item, i) => {
            lines.push((i + 1) + ') ' + (item.name || item.id || ''));
          });
        } else {
          lines.push('—');
        }
        lines.push('');
        lines.push('Packs:');
        if (ante.packs && ante.packs.length) {
          ante.packs.forEach(pack => {
            const items = pack.items && pack.items.length ? pack.items.join(', ') : '—';
            lines.push(pack.type + ' - ' + items);
          });
        } else {
          lines.push('—');
        }
        lines.push('');
      }
      return lines.join('\n');
    }

    function normalizeSeed(seed) {
      if (!seed) return null;
      const s = seed.trim().toUpperCase().replace(/0/g, 'O');
      if (s.length !== 8) return null;
      if (!/^[A-Z1-9]+$/.test(s)) return null;
      return s;
    }

    function splitTokens(raw) {
      return raw
        .split(/[,\s]+/g)
        .map(t => t.trim())
        .filter(Boolean);
    }

    function buildSeedList() {
      const tokens = [];
      if (seedListEl.value.trim()) tokens.push(...splitTokens(seedListEl.value));
      if (seedFileText) tokens.push(...splitTokens(seedFileText));
      if (!tokens.length) return null;
      return tokens.join(',');
    }

    function buildKeywordList() {
      const tokens = [];
      if (keywordEl.value.trim()) tokens.push(keywordEl.value.trim());
      if (keywordListEl.value.trim()) tokens.push(...splitTokens(keywordListEl.value));
      if (keywordFileText) tokens.push(...splitTokens(keywordFileText));
      return tokens
        .map(t => t.toUpperCase().replace(/0/g, 'O'))
        .filter(Boolean);
    }

    function parseOptionalNumber(el) {
      const raw = el.value.trim();
      if (!raw) return null;
      const n = Number(raw);
      return Number.isFinite(n) ? n : null;
    }

    function setActiveTab(next) {
      activeTab = next;
      const buttons = searchTabs.querySelectorAll('.tab-btn');
      buttons.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === next));
      const panels = document.querySelectorAll('.tab-panel');
      panels.forEach(panel => panel.classList.toggle('active', panel.dataset.tabPanel === next));
    }

    (async function run() {
      try {
        const { dotnet } = await import('./_framework/dotnet.js');
        status.textContent = 'Initializing .NET runtime...';
        const { getAssemblyExports, getConfig } = await dotnet.create();
        status.textContent = 'Loading assembly exports...';
        const config = getConfig();
        const exports = await getAssemblyExports(config.mainAssemblyName);
        const api = exports.Motely.WASM.MotelyWasm;

        status.textContent = 'Ready';
        status.className = 'success';
        controls.style.display = 'block';
        setActiveTab('seed');
        out.value = 'Ready. Enter a seed and click Analyze.';

        analyzeBtn.onclick = async () => {
          const seed = document.getElementById('seed').value.trim() || 'TACO1111';
          const deck = document.getElementById('deck').value.trim() || 'Red';
          const stake = document.getElementById('stake').value.trim() || 'White';
          const minAnte = parseInt(document.getElementById('minAnte').value, 10) || 1;
          const maxAnte = parseInt(document.getElementById('maxAnte').value, 10) || 8;
          analyzeBtn.disabled = true;
          status.className = '';
          out.value = 'Analyzing...';
          try {
            const json = await api.AnalyzeSeed(seed, deck, stake, minAnte, maxAnte, '{}');
            const data = JSON.parse(json);
            rawJsonEl.textContent = JSON.stringify(data, null, 2);
            out.value = formatAnalysis(data);
            out.classList.remove('error');
          } catch (e) {
            out.value = 'Error: ' + e.message + (e.stack ? '\n\n' + e.stack : '');
            out.classList.add('error');
          } finally {
            analyzeBtn.disabled = false;
          }
        };

        clearBtn.onclick = () => {
          out.value = '';
          rawJsonEl.textContent = '—';
        };

        seedFileEl.addEventListener('change', async (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) {
            seedFileText = '';
            return;
          }
          seedFileText = await file.text();
        });

        keywordFileEl.addEventListener('change', async (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) {
            keywordFileText = '';
            return;
          }
          keywordFileText = await file.text();
        });

        searchTabs.addEventListener('click', (e) => {
          const btn = e.target.closest('.tab-btn');
          if (!btn) return;
          setActiveTab(btn.dataset.tab);
        });

        async function runSearchOnce(jaml, options, label) {
          return new Promise(async (resolve, reject) => {
            const streamedResults = [];
            globalThis.MotelyWasmOnProgress = (progressJson) => {
              const p = JSON.parse(progressJson);
              const rate = (p.seedsPerSecond ?? 0).toFixed(0);
              const prefix = label ? label + ' — ' : '';
              searchOut.value = prefix + p.status + ' — searched ' + (p.searchedCount ?? 0).toLocaleString() + ', found ' + (p.foundCount ?? 0) + ' @ ' + rate + '/s';
            };
            globalThis.MotelyWasmOnResult = (seed, score, talliesStr) => {
              streamedResults.push({ seed, score, tallies: talliesStr || '' });
            };
            globalThis.MotelyWasmOnComplete = (resultJson) => {
              const data = resultJson === 'null' ? {} : JSON.parse(resultJson);
              resolve({ data, streamedResults });
            };

            try {
              if (typeof api.SearchSeedsWithOptions === 'function') {
                await api.SearchSeedsWithOptions(jaml, JSON.stringify(options));
              } else {
                const fallbackSeedList = options.seedList ?? null;
                await api.SearchSeeds(jaml, fallbackSeedList, options.threadCount ?? 0);
              }
            } catch (e) {
              reject(e);
            }
          });
        }

        searchBtn.onclick = async () => {
          const jaml = jamlEl.value.trim();
          if (!jaml) {
            searchOut.value = 'Paste or edit a JAML filter.';
            return;
          }
          const threadCountRaw = threadCountEl.value.trim()
            ? parseInt(threadCountEl.value, 10)
            : (typeof navigator !== 'undefined' && navigator.hardwareConcurrency ? navigator.hardwareConcurrency : 4);
          const threadCount = Math.max(1, Math.min(32, threadCountRaw || 4));
          const batchSize = parseOptionalNumber(batchSizeEl) ?? 4;
          const padding = paddingCharsEl.value.trim() || null;

          searchBtn.disabled = true;
          cancelBtn.style.display = 'inline-block';
          searchOut.value = 'Starting search...';
          searchJson.textContent = '—';
          cancelRequested = false;

          const optionsBase = {
            threadCount,
            batchSize,
            padding: padding || undefined,
            startSeed: startSeedEl.value.trim() || undefined,
            startPercent: parseOptionalNumber(startPercentEl) ?? undefined,
            endPercent: parseOptionalNumber(endPercentEl) ?? undefined,
            startBatch: parseOptionalNumber(startBatchEl) ?? undefined,
            endBatch: parseOptionalNumber(endBatchEl) ?? undefined,
            cutoff: cutoffEl.value.trim() || undefined,
          };

          try {
            let keywordRuns = [null];
            if (activeTab === 'keyword') {
              const keywords = buildKeywordList();
              keywordRuns = keywords.length ? keywords : [null];
              if (!keywords.length) {
                throw new Error('Enter at least one keyword.');
              }
            }

            const aggregated = [];
            for (let i = 0; i < keywordRuns.length; i++) {
              if (cancelRequested) break;
              const keyword = keywordRuns[i];
              const options = { ...optionsBase };
              if (activeTab === 'seed') {
                const seedList = buildSeedList();
                if (!seedList) {
                  throw new Error('Provide a seed list or seed list file.');
                }
                options.seedList = seedList;
              } else if (activeTab === 'keyword') {
                options.keyword = keyword;
                options.seedList = undefined;
              } else if (activeTab === 'random') {
                const count = parseOptionalNumber(randomSeedsEl);
                if (!count || count < 1) {
                  throw new Error('Random mode requires a positive Random seeds value.');
                }
                options.randomSeeds = count;
              } else if (activeTab === 'palindrome') {
                if (!palindromeEl.checked) {
                  throw new Error('Palindrome mode requires the checkbox to be enabled.');
                }
                options.palindrome = true;
              }
              const label = keyword ? `Keyword ${i + 1}/${keywordRuns.length}: ${keyword}` : '';
              const { data, streamedResults } = await runSearchOnce(jaml, options, label);
              if (data && data.error) {
                searchOut.value = 'Error: ' + data.error;
                searchOut.classList.add('error');
                break;
              }
              const total = data.totalSearched ?? 0;
              const found = data.foundCount ?? streamedResults.length;
              aggregated.push({
                keyword: keyword || null,
                totalSearched: total,
                foundCount: found,
                results: streamedResults
              });
              if (data.cancelled) {
                cancelRequested = true;
                break;
              }
            }

            const lines = [];
            aggregated.forEach((run, idx) => {
              if (run.keyword) {
                lines.push('== ' + run.keyword + ' ==');
              } else if (aggregated.length > 1) {
                lines.push('== Run ' + (idx + 1) + ' ==');
              }
              lines.push('Found ' + run.foundCount + ' result(s) after searching ' + run.totalSearched.toLocaleString() + ' seeds.');
              lines.push('');
              run.results.forEach((r, i) => {
                const tail = r.tallies ? ' | ' + r.tallies : '';
                lines.push((i + 1) + ') ' + r.seed + ' — score ' + r.score + tail);
              });
              lines.push('');
            });
            searchOut.value = lines.length ? lines.join('\n') : 'No results.';
            searchJson.textContent = JSON.stringify({ runs: aggregated }, null, 2);
            searchOut.classList.remove('error');
          } catch (e) {
            searchOut.value = 'Error: ' + e.message + (e.stack ? '\n\n' + e.stack : '');
            searchOut.classList.add('error');
          } finally {
            searchBtn.disabled = false;
            cancelBtn.style.display = 'none';
          }
        };

        cancelBtn.onclick = async () => {
          cancelRequested = true;
          await api.CancelSearch();
          searchOut.value = 'Cancelling...';
        };
      } catch (e) {
        status.textContent = 'Failed to load';
        status.className = 'error';
        out.value = e.message + '\n\n' + (e.stack || '');
        out.classList.add('error');
      }
    })();
  </script>
</body>
</html>
